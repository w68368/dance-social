generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

// Types of reactions to a post
enum ReactionType {
  LIKE   // regular like / heart
  FIRE   // fire
  WOW    // wow
  CUTE   // cute / vibey
  CLAP   // applause
}

model User {
  id                  String          @id @default(cuid())
  email               String          @unique

  // technical @username (slug, no spaces, lowercase)
  username            String          @unique
  // how the user wrote their nickname (with spaces, capital letters, etc.)
  displayName         String?

  passwordHash        String
  avatarUrl           String?
  failedLoginAttempts Int             @default(0)
  lockUntil           DateTime?

  // whether the email is verified
  emailVerifiedAt     DateTime?

  // ===== Relations =====
  refreshTokens       RefreshToken[]
  passwordResets      PasswordReset[]

  // Relation to posts
  posts               Post[]

  // Reactions to posts made by the user
  postReactions       PostReaction[]

  comments            PostComment[]
  // Likes on comments made by the user
  likedComments       CommentLike[]

  // Follows
  // users who FOLLOW this user
  followers           Follow[] @relation("FollowFollowing")
  // users that THIS user FOLLOWS
  following           Follow[] @relation("FollowFollower")

  // Chats
  conversationParticipants ConversationParticipant[]
  sentMessages            Message[]

  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  @@index([lockUntil])
}

model RefreshToken {
  id         String   @id @default(cuid())
  userId     String
  tokenHash  String   @unique
  userAgent  String?
  ip         String?
  createdAt  DateTime @default(now())
  expiresAt  DateTime
  revokedAt  DateTime?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
}

//
// Email confirmation table
//
model EmailVerification {
  id          String    @id @default(cuid())
  email       String    @unique
  codeHash    String
  expiresAt   DateTime
  attempts    Int       @default(0)
  maxAttempts Int       @default(5)
  payload     Json
  createdAt   DateTime  @default(now())
}

//
// Password reset table
//
model PasswordReset {
  id           String   @id @default(cuid())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String

  tokenHash    String   @unique
  expiresAt    DateTime
  usedAt       DateTime?
  createdAt    DateTime @default(now())

  requestedIp  String?
  requestedUA  String?

  @@index([expiresAt])
}

//
// Table of posts
//
model Post {
  id        String   @id @default(cuid())

  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String

  caption   String

  mediaType      String?  // "image" | "video"
  mediaUrl       String?
  mediaLocalPath String?

  // Reactions
  reactions PostReaction[]
  comments  PostComment[]
  hashtags  PostHashtag[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([authorId, createdAt])
}

//
// ðŸ†• Follow table
// followerId  â€” the user who follows
// followingId â€” the user being followed
//
model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  // the user who started following
  follower  User @relation("FollowFollower", fields: [followerId], references: [id])
  // the user who is being followed
  following User @relation("FollowFollowing", fields: [followingId], references: [id])

  // cannot follow the same user twice
  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model PostComment {
  id   String @id @default(cuid())
  text String

  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String

  author   User @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId String

  // nested comments (replies)
  parent   PostComment?   @relation("CommentReplies", fields: [parentId], references: [id])
  parentId String?
  replies  PostComment[]  @relation("CommentReplies")

  // Comment likes
  likes    CommentLike[]

  // Whether the comment is pinned on the post
  isPinned Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
  @@index([postId, isPinned])
}

//
// ðŸ†• Comment likes table
//
model CommentLike {
  id        String   @id @default(cuid())

  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  comment   PostComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId String

  createdAt DateTime @default(now())

  // one like per user per comment
  @@unique([userId, commentId])
  @@index([commentId])
}

//
// ðŸ†• Table of post reactions
// one row = one reaction from one user to one post
//
model PostReaction {
  id        String        @id @default(cuid())

  post      Post          @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String

  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String

  type      ReactionType
  createdAt DateTime      @default(now())

  // one reaction per post per user
  @@unique([postId, userId], name: "postId_userId")
  @@index([postId])
  @@index([userId])
}

//
// ðŸ†• Hashtag table for autocomplete and analytics
//
model Hashtag {
  id        String        @id @default(cuid())
  tag       String        @unique  // text without #, lowercase, e.g. "hiphop"
  createdAt DateTime      @default(now())

  // posts associated with this hashtag
  posts     PostHashtag[]

  @@index([tag])
}

//
// ðŸ†• Linking table "post â†” hashtag"
//
model PostHashtag {
  id        String   @id @default(cuid())

  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String

  hashtag   Hashtag  @relation(fields: [hashtagId], references: [id], onDelete: Cascade)
  hashtagId String

  // the same tag cannot be attached to the same post twice
  @@unique([postId, hashtagId])

  @@index([postId])
  @@index([hashtagId])
}

//
// =========================
// Chats (DM)
// =========================
model Conversation {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  participants ConversationParticipant[]
  messages     Message[]

  @@index([updatedAt])
}

model ConversationParticipant {
  id             String       @id @default(cuid())
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String

  createdAt DateTime @default(now())

  @@unique([conversationId, userId])
  @@index([userId])
}

model Message {
  id             String       @id @default(cuid())

  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  conversationId String

  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  senderId       String

  text           String
  createdAt      DateTime     @default(now())
  editedAt       DateTime?

  // Reply
  replyToId      String?
  replyTo        Message?     @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies        Message[]    @relation("MessageReplies")

  @@index([conversationId, createdAt])
  @@index([replyToId])
}

